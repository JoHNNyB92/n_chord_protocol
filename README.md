# N-Chord protocol simulation

The simulated system contains N different nodes (N is a system parameter given by the user) and each node stores a list of contacts as described in the Chord protocol (successor, predecessor, and fingers). Since it is a simulated and not a real distributed system, communication (i.e., message sending, message receiving) between the different nodes are conducted by writing in an appropriate share memory that is read by each node. At the end of the process, a node n sends a message to node n’ by writing the message to a predefined area of n’ that is reserved for incoming messages. Each node knows only the nodes that are present in its finger table, the successor and predecessor node.

The simulation is carried out in turns (the number of turns is a system parameter given by the user) where in the beginning of each turn all nodes read the incoming messages, perform the appropriate actions, and write their outgoing messages to the areas of the recipient nodes.

A node can fail or no, it is based on the stabilization protocol. A basic “stabilization” protocol is used to keep nodes’ successor pointers up to date, which is sufficient to guarantee correctness of lookups. Those successor pointers are then used to verify and correct finger table entries, which allows these lookups to be fast as well as correct. In our implementation we have considered that nodes do not fail.

In the end we have experimented with different network sizes and different query loads (query load is a system parameter given by the user and it is the number of queries that random nodes will initiate) to get measurements. The experiments were run multiple times in order to take many results and to calculate the average (or median, or mean) of them. Measurements are regarding the number of messages needed to locate a single file, the observed latency (measured in the size of a chain of messages needed to locate a file), and the load of each node (in terms of requests for a file and messages routed).
